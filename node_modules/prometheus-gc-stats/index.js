'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _counter = require('prom-client/lib/counter');

var _counter2 = _interopRequireDefault(_counter);

var _optional = require('optional');

var _optional2 = _interopRequireDefault(_optional);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Credits go to @tcolgate

var gc = (0, _optional2.default)('gc-stats');

var gcTypes = {
  0: 'Unknown',
  1: 'Scavenge',
  2: 'MarkSweepCompact',
  3: 'ScavengeAndMarkSweepCompact',
  4: 'IncrementalMarking',
  8: 'WeakPhantom',
  15: 'All'
};

var noop = function noop() {};

exports.default = function () {
  if (typeof gc !== 'function') {
    return noop;
  }

  var gcCount = new _counter2.default('nodejs_gc_runs_total', 'Count of total garbage collections.', ['gctype']);
  var gcTimeCount = new _counter2.default('nodejs_gc_pause_seconds_total', 'Time spent in GC Pause in seconds.', ['gctype']);
  var gcReclaimedCount = new _counter2.default('nodejs_gc_reclaimed_bytes_total', 'Total number of bytes reclaimed by GC.', ['gctype']);

  var started = false;

  return function () {
    if (started !== true) {
      started = true;

      gc().on('stats', function (stats) {
        var gcType = gcTypes[stats.gctype];

        gcCount.labels(gcType).inc();
        gcTimeCount.labels(gcType).inc(stats.pause / 1e9);

        if (stats.diff.usedHeapSize < 0) {
          gcReclaimedCount.labels(gcType).inc(stats.diff.usedHeapSize * -1);
        }
      });
    }
  };
};

module.exports = exports['default'];
